# 连接起前后端的红绳

首先，恭喜您完成了超过一半的课题内容。能坚持看到现在非常不容易，尤其是在前两天经历了前后端的大量知识冲击之后。这个课题安排非常紧凑，所以可能您会感到困惑，这是正常的——我之前没有写过这种短周期的系统性教程。所以，记得有任何问题随时提出，有任何想法随时表达；无论是对自己的了解，还是对于改进这个话题，为其他人提供可能的帮助，也都是有好处的。

::: tip

今天的内容是对 HTTP 的深度解析，会非常的枯燥，对于实际开发来说的帮助没有那么立竿见影，更多的是讲一讲一些具体的细节和可以用来提升开发者友好程度相关的东西。如果您觉得没有兴趣看下去，可以暂时先不来看这些。

:::

在对基础的前后端知识有一个简单的了解之后，今天我们来讲讲它们背后共通但又有所不同的东西，也是一位我们熟悉的新朋友： HTTP 。

## 什么是 HTTP

HTTP 的定义非常简单，就像 HTML 一样， HTTP 就是 **H**yper**T**ext **T**ransfer **P**rotocol 的缩写。翻译过来，就是一个用于传输 `hypertext` 的协议。如果您了解过 [OSI 七层模型]，一般认为它运行在 Layer 7 *应用层*， Layer 4 的 TCP/IP ( HTTP/3 也会用到 QUIC ) 是它的基础。我们会在 Day 7 来讲一讲关于分别对应这两大层的防护技术。

[OSI 七层模型]: https://en.wikipedia.org/wiki/OSI_model

还记得您第一次听说 HTTP 的时候吗？或许是输入网址时候的 `https://...` ，或者是在网站上看到的某个可以点击的链接。它是什么？

### URL 的解析

对于形如这种的东西，我们称它为一个 URL ，它可以用来定位到网络上的一处资源。 RFC3986 中定义了非常详细的规范，这里只给出我们常用的一个缩略范例（方括号中的内容表示可以省略）：

```
scheme://[userinfo@]hostname[:port]path[?query][#fragment]
```

例如，对于一个形如 `http://localhost:1323/?start=1&end=100` 的链接来说，它的各个部分分别是这样的：

| 部分     | 值              |
| -------- | --------------- |
| scheme   | http            |
| userinfo |                 |
| hostname | localhost       |
| port     | 1323            |
| path     | /               |
| query    | start=1&end=100 |
| fragment |                 |

- scheme 是协议。最常见的协议有 HTTP 和 HTTPS ，其次我想或许不少人用过 mailto 、 ftp ，或是 smb 等等。还记得我们昨天用来连接数据库和 redis 时使用的以 `postgres` 和 `redis` 开头的字符串吗？这两个字符串也是 URL ，这两个开头也是协议。
- userinfo 是指用户信息。一个简单的例子就是邮件地址，例如 `example@nya.one` 来说， `example` 就是 userinfo 。另一个较为常见的案例是使用 HTTP Basic Authentication 作为认证方案的场景中，使用 `username:password` 这样的格式来编码用户名和密码。
- hostname 是指主机名，这应该是我们最常使用的部分。例如，我们记忆喵窝的地址的时候，可以使用 `nya.one` ——这就是域名格式的主机名。或是例如在维护路由器的时候，我们会使用 `192.168.0.1` ，这个是以 IP 格式呈现的主机名。
- port 是指端口。通常当我们使用 scheme 对应的默认端口（ HTTP 80 / HTTPS 443 ）时可以省略它，也因此我们并不常在一些在线服务上看到它；但对于因为出于种种原因没有使用默认端口，例如本地调试，或是在国内自己家里部署可供外部访问的服务器时，则需要指定它。
- path 是路径。这个就像文件路径一样，没有什么特别的。
- query 是查询，用于传递一些参数。这个参数一般主要出现在搜索引擎的搜索时，或是在一些跳转路径中较多出现。不同的查询参数使用 `&` 连接，同名的查询参数会被认为是数组元素。
- fragment 通常用于指定某个页面上的指定位置，例如在浏览器默认行为中可以用来定位到对应的标题。对于使用 hash route 的 SPA 应用来说，它可以被用于存储路由。这个参数仅在浏览器内部生效，不会被发往服务器。

::: tip URL 与 URI

您可能会听说过 URI 这个缩写。 URI 乍看之下好像和 URL 差不多，但它的范围更广一些： URL 是用于 locate 一个 UR ，而 URI 仅仅是一个 identifier ，它还包含了 URN 这个不用于 locate 资源的纯 name 结构。

在 HTTP 请求领域，我们一般使用 URL 比较多，在一些时候也可能会使用到 URN ，但这又是后话了。

:::

### 发出一个请求

有了一个 URL 之后，我们应该如何发出请求呢？

HTTP 以报文的格式在服务端与客户端（例如浏览器）之间通讯。一个 HTTP/1.1 以及更早的 HTTP 协议报文是语义可读的，一个请求报文分为 请求行、 请求头 、 请求体（可选）三大部分。我们分别来看它们。

#### 请求行

一个请求行由三个使用单空格分隔的部分组成：请求方法（method）、请求路径（包含 query）和请求使用的 HTTP 版本号。它长这样：

```
GET /full-stack-in-7-days/welcome-to-http/ HTTP/1.1
```

##### 请求方法

首先是请求方法。 HTTP 中定义了许多请求方法。根据我个人的开发使用习惯，我会把它们分成两类：

- 常用的： `GET` `POST` `PUT` `PATCH` `DELETE`
- 不常用的： `HEAD` `OPTIONS` `CONNECT` `TRACE`

我们先来看看常见的方法。

- 先说最常见的 GET 。还记得我们昨天写 echo 服务时候使用的这行代码吗？

  ```go line-numbers=18
  e.GET("/", hello)
  ```

  这里的 `GET` ，就是 HTTP 方法里的 GET 。这是因为浏览器在打开一个 URL 时，默认使用的是 GET 方法。

  GET 方法非常简单，一般被用在只读的获取数据场合。它不能携带请求体（可以被服务端忽略），所以所有需要的参数一般通过在路径中的 query 来传递，或是对于包含动态路径的场合使用路径来传递：就像昨天课后挑战里的样例程序，我们通过 query 来向 echo 服务器传递所需的起始和结束参数；对于这个课题的文档项目来说，通过不同页面的路径不同来对应获取。虽然 HTTP 对 URL 的限制非常宽泛，并且会使用编码来传递一些非 Ascii 字符，但一般我们不推荐使用 GET 请求来做一些会对服务器数据产生影响的操作——限制太大，实在没必要。

- 第二常用的是 POST 方法。相较于 GET 方法的限制来说，它因为可以携带请求体，所以通常会被用在需要对服务器数据进行改动的场合。传统的 HTTP 请求，例如表单提交中，通常会指定 method 为 POST 来调用它。使用请求体来传递参数有两大好处：一是不会干扰到 URL 从而避免让浏览器的历史记录变得混乱，让链接变得冗长；二是能用来传递一些非常大块的请求数据，例如文件上传——可以使用 `multipart/form-data` 来编码它们。

- 那么， PUT 和 PATCH 又是什么呢？

  其实，就效果来讲，它们和 POST 并没有什么区别：甚至从纯技术角度来讲，您完全可以用 PATCH 请求来创建资源：但这种反直觉的设计一般不推荐使用在愚人节恶搞之外的场合——实在是太不像是碳基生物能整出来的让人眼前一黑的活了。用 PUT 来统一创建或更新资源的操作倒也还挺好用，在创建指定标识的资源时可以更方便开发者的使用。从语义上来讲， PUT 是指使用一整个新的数据来替换掉旧的，而 PATCH 则是对指出项目的修改。

- 至于 DELETE ，它的限制同样是不能携带请求体，因而需要使用路径或是 query 来传递需要被删除的资源标识；但它与 GET 不同的是，在语义上它是会对后端数据产生影响的，即一份数据在被删除之后无法再被操作（取消删除除外），因而也有其特殊的使用场景。

由此我们可以发现，在上述这些较为常见的请求方法中，最不受限制、功能丰富、语义限制小的是 POST ；一些应用（如 Misskey ）会将其所有的操作都使用 POST 进行封装，以避免语义上的歧义导致开发工作的管理出现困难；或是对于像 GraphQL 这种由客户端构建查询请求的接口封装方案来说，因为它的每一次请求都需要包含类型结构体、包含具体操作的参数，因而全部使用 POST 方法来进行封装是一种较为常用的设计。

另一种想法也很直接，即较为严格地遵循每一种方法对应的语义，来进行对应接口的封装，这就是著名的 RESTful API 规范了。我们之后会稍微再展开讲一讲这两种主流规范之间的关系和适用场景。

我们再来看看这些不太常见的方法。

- HEAD 用来获得目标资源的响应头，忽略掉目标资源的请求体：可以用在例如多线程下载时，请求文件大小并进行下载分段初始化的场景中；或是像 S3 请求中，用于获得文件元数据的时候。它类似 GET ，但不会获得响应体，因而非常适用于一些仅需要元数据，而不需要在意具体内容的场合。
- OPTIONS 多见于在跨域请求（CORS）前检测目标服务器是否可被调用时，浏览器自动发出的 [preflight 请求] 场景。我似乎没有见到过主动使用它的情况。
- CONNECT 和 TRACE 就更少见了，我没有在实际使用场景中见到过它们。参见 MDN 文档 [HTTP 请求方法] 中给出的提示信息，我们可以更好地了解它们。

[preflight 请求]: https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request
[HTTP 请求方法]: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods

##### 路径

路径就是 URL 规范里的 `path[?query]` 这一部分，没什么好展开讲的，我们主要来简单了解一下版本号。

##### 版本号

目前最广泛使用的是 HTTP/1.1 ，它是一个发布于千禧年之前的 HTTP 标准，虽然非常古老，但其实现了 HTTP 通信及一些升级协议所必需的组件，也因此时至如今也依然具有强大的生命力。

但随着互联网带宽不断扩展，对于多媒体和复杂内容的需求也逐渐增加， HTTP/1.1 的旧设计中没有考虑到的情况限制了其传输的峰值性能。 2015 年， HTTP/2 被推出：它并没有改变 HTTP/1.1 的应用层结构（如请求方法、请求路径、响应状态、消息结构等），而是从传输编码和数据流优化的角度入手，将消息封装成帧（frame）来传输，并使用多路复用技术来提升在同一个 TCP 连接中可以传输的数据，从而避免在多次请求时反复创建连接造成的不必要性能开销问题。时至今日，现代互联网上已经有不少网站支持了基于 HTTP/2 的连接。

HTTP/3 的出现则更像是对传统 TCP/IP 通信为主的历代 HTTP 协议的一次革新。它使用了 QUIC 协议进行通信，从而解决了 HTTP/2 协议的多路复用中 TCP 的丢包恢复限制——对于 HTTP/2 来说，任何 TCP 连接中的丢包中断都会阻塞整条数据流，导致并用该条流的响应出现延迟； HTTP/3 使用的 QUIC 自带有多路复用支持，在出现请求丢包时只有该包所在的数据流会出现延迟，其他的部分仍然都正常传递，从而在不是非常稳定的网络场景下会拥有更为优秀的性能。另外， QUIC 使用的 UDP 也不需要像 TCP 那样三次握手之后才能通信，在连接的起始阶段也能达到相当优异的首字节响应（TTFB）速度。

有趣的是，它们和 TLS 加密之间的关系也是层层递进的。 HTTP/1.1 中的加密是可选的，而在 HTTP/2 和 3 中则对于 TLS 加密提出了一些要求。这也就是为什么我们在本地打开的 http 连接通常都是 HTTP/1.1 ，因为本地连接时仅需考虑显示与交互上的正确性，安全性上考虑则更多的来源于生产环境部署场景的需求。

::: info 如果您有兴趣继续深入了解一下它们，这里是一些可以尝试的阅读材料：

- [HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)
- [HTTP/2 - Wikipedia](https://en.wikipedia.org/wiki/HTTP/2)
- [什么是 HTTP？为什么 HTTP/2 比 HTTP/1.1 快？ | Cloudflare](https://www.cloudflare.com/zh-cn/learning/performance/http2-vs-http1.1/)
- [HTTP/3 - Wikipedia](https://en.wikipedia.org/wiki/HTTP/3)
- [Comparing HTTP/3 vs. HTTP/2 Performance | Cloudflare Blog](https://blog.cloudflare.com/http-3-vs-http-2)

:::

#### 请求头

再让我们看回 HTTP/1.1 。在请求行结束之后，我们来看请求头，也就是这样的一组 KV 键值对：

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8,ja;q=0.7
Cache-Control: max-age=0
Connection: keep-alive
Cookie: userToken=n9ijka719lgmnu99o5p5ve; Webstorm-c0f4a935=f6070343-711c-43b6-93bd-e7106453c340
Host: localhost:5173
Referer: http://localhost:5173/full-stack-in-7-days/welcome-to-http/
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-origin
Sec-Fetch-User: ?1
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36
sec-ch-ua: "Chromium";v="122", "Not(A:Brand";v="24", "Google Chrome";v="122"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
```

不要害怕，我们一点一点来看。

首先是结构。您会发现每一行请求头都是 `Key: Value` 的结构，即使用一个冒号和一个空格将键值分开。键的名称通常是短划线（减号）分割的首字母大写的单词组合，但也有一些没有大写的场景；值则是千奇百怪的结构，但都在一行之内。

对于 HTTP 请求来说，首字母大写只是一种较为推荐的书写方式，但因为它并不对大小写敏感，所以有时您也会看到使用全小写的情况，就像这个样例。出于一致性考虑，我们还是更推荐使用首字母大写的结构（除非特别说明），来避免在不同应用间传递时因可能的处理方法实现不完全导致错误丢失数据的情况出现。

HTTP 中定义了一些基本的请求头名称（键），但对于想要自行扩展的用法来说，自行补充需要的定义即可。这里我们简单讲几个有代表性的。

在传统的 HTTP 认证方式中，通常会使用 `Cookie` 来存储会话标识，从而维持客户端在服务端的身份，例如登录网站之后的用户层操作；但随着前端技术的逐渐发展，不少执行被转移到客户端来进行，尤其是在前后端分离场景下 Cookie 的一些限制让它不再易用，因而使用 localStorage 或 sessionStorage 来存储会话令牌、使用 `Authorization` 请求头来在请求中指定认证信息的操作也逐渐出现。

您可能在之前听说过 `User-Agent` 这一项，可以看到在现在这个样例中它是长长的一串，充满了各个浏览器之间兼容性差异的历史遗留泪水。它用于标识发出请求的客户端，例如浏览器，或是 curl wget 这样的命令行工具，或是任何其他自定义使用的值。

对于含有请求体的请求来说，它们会包含一项 `Content-Type` 来标明请求体的结构。对我来说，比较常用的内容类型有两种： `application/json` 用来上传信息， `multipart/form-data` 用来上传文件。在一些场景中，您也可能会看到 `application/x-www-form-urlencoded` 这样的类型，它可能会出现在一些使用 form 表单的传统三大件项目中；对于现代开发来说，使用 JSON 来封装需要传递的信息会更为方便快捷。

您可能会听说过一些关于 `Referer` 的趣闻。是的，它是一个谬拼，正确的写法应该是 referrer ，只是在编写规范文档时拼错了，所以也就一直将错就错使用下来了。它表示的是当前的请求是从哪个请求引申出来的，一个比较常见的用法是用于追踪从不同来源（如搜索引擎、 SNS 平台或是其他来源）的用户访问情况，另一个用法则是对一些媒体资源实例启动防盗链保护——防止未经授权的站点直接引用它们。在一些平台，例如 GitLab 的登录后跳转回登录前页面的逻辑中，有时也能看到它的身影。

`Host` 也是一个非常有趣的请求头，我们会在之后讲到它。

#### 请求体

请求体，是指请求携带的数据，一般用在较大量数据传递，或是涉及到后端数据变化的场合。例如表单提交、文件上传等，会将涉及到的内容都放置在请求体中，以便后端的接收与处理。

在 HTTP/1.1 的规范中，请求体与请求头之间使用一个空行隔开，并延伸直至整个请求报文结束。

### 获得一个响应

HTTP/1.1 的响应与请求类似，也以报文的格式呈现。第一行是响应行，接下来是响应头，空行之后是响应体。响应头与响应体和请求的类似，就不多讲述了；我们主要来看看响应行。

响应行由 HTTP 版本号、响应状态码（status code）和状态短语（status message）组成，就像这样：

```
HTTP/1.1 200 OK
```

不出意外的话， HTTP 版本号会与发出 HTTP 请求时使用的版本号一致。例如我们使用 HTTP/1.1 发出请求报文，收到使用 HTTP/1.1 封装的响应报文。

响应状态码和对应的状态短语是一个很有趣的东西。例如我们非常常用的 404 来指代不存在的东西，就是使用了 `HTTP 404 Not Found` 这个状态。

一般的状态码定义为三位数，第一个数字用于表示所处的状态大组，大致定义如下：

| 状态码 | 大组含义           |
| ------ | ------------------ |
| 1xx    | 收到请求，继续处理 |
| 2xx    | 收到请求，没有问题 |
| 3xx    | 重定向跳转         |
| 4xx    | 客户端请求出错     |
| 5xx    | 服务端出错         |

::: tip

如果您想要快速对各种 HTTP 状态码有一个初步印象，可以参考 [http.cat] 这个网站。

[http.cat]: https://http.cat/

:::

### RPC 响应与流式处理

WebSocket

引申技术 gRPC

### DNS 与 Host

### 请求头与请求体

### TLS 加密

### SNI 泄露与 ECH 草案

## 浏览器能做的事

XMLHttpRequest， axios 与 fetch API

## 跨域资源共享（CORS）的处理

## 开发调试好帮手

### API 规范

### 请求测试工具

## 主流的规范

### REST API

### GraphQL

## 今日总结

## 课后挑战
